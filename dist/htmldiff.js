(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["HtmlDiff"] = factory();
	else
		root["HtmlDiff"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\r\n\r\nManually translated to JS from C#.\r\nOriginal: https://github.com/Rohland/htmldiff.net\r\nOriginal was actually a .net port of a Ruby implementation: https://github.com/myobie/htmldiff\r\nThere also looks to be other implementations in CoffeeScript, as well as an Angular module.\r\n\r\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar HtmlDiff = function HtmlDiff(oldText, newText) {\n    /// <summary>\n    /// This value defines balance between speed and memory utilization. The higher it is the faster it works and more memory consumes.\n    /// </summary>\n    this.MatchGranularityMaximum = 4;\n\n    this._content = [];\n    this._newText = newText;\n    this._oldText = oldText;\n    var that = this;\n\n    this._specialCaseClosingTags = {\n        '</strong>': 0,\n        '</em>': 0,\n        '</b>': 0,\n        '</i>': 0,\n        '</big>': 0,\n        '</small>': 0,\n        '</u>': 0,\n        '</sub>': 0,\n        '</sup>': 0,\n        '</strike>': 0,\n        '</s>': 0\n    };\n\n    this._specialCaseOpeningTagRegex = new RegExp(/<((strong)|(b)|(i)|(em)|(big)|(small)|(u)|(sub)|(sup)|(strike)|(s))[>\\s]+/i);\n\n    this._specialTagDiffStack = [];\n\n    this._newWords;\n    this._oldWords;\n    this._matchGranularity;\n    this._blockExpressions = [];\n\n    /// <summary>\n    /// Defines how to compare repeating words. Valid values are from 0 to 1.\n    /// This value allows to exclude some words from comparison that eventually\n    /// reduces the total time of the diff algorithm.\n    /// 0 means that all words are excluded so the diff will not find any matching words at all.\n    /// 1 (default value) means that all words participate in comparison so this is the most accurate case.\n    /// 0.5 means that any word that occurs more than 50% times may be excluded from comparison. This doesn't\n    /// mean that such words will definitely be excluded but only gives a permission to exclude them if necessary.\n    /// </summary>\n    this.RepeatingWordsAccuracy = 1;\n\n    /// <summary>\n    /// If true all whitespaces are considered as equal\n    /// </summary>\n    this.IgnoreWhitespaceDifferences = false;\n\n    /// <summary>\n    /// If some match is too small and located far from its neighbors then it is considered as orphan\n    /// and removed. For example:\n    /// <code>\n    /// aaaaa bb ccccccccc dddddd ee\n    /// 11111 bb 222222222 dddddd ee\n    /// </code>\n    /// will find two matches <code>bb</code> and <code>dddddd ee</code> but the first will be considered\n    /// as orphan and ignored, as result it will consider texts <code>aaaaa bb ccccccccc</code> and\n    /// <code>11111 bb 222222222</code> as single replacement:\n    /// <code>\n    /// &lt;del&gt;aaaaa bb ccccccccc&lt;/del&gt;&lt;ins&gt;11111 bb 222222222&lt;/ins&gt; dddddd ee\n    /// </code>\n    /// This property defines relative size of the match to be considered as orphan, from 0 to 1.\n    /// 1 means that all matches will be considered as orphans.\n    /// 0 (default) means that no match will be considered as orphan.\n    /// 0.2 means that if match length is less than 20% of distance between its neighbors it is considered as orphan.\n    /// </summary>\n    this.OrphanMatchThreshold = 0;\n\n    /// <summary>\n    /// Builds the HTML diff output\n    /// </summary>\n    /// <returns>HTML diff markup</returns>\n    this.Build = function () {\n        // If there is no difference, don't bother checking for differences\n        if (that._oldText == that._newText) {\n            return that._newText;\n        }\n\n        SplitInputsToWords();\n\n        that._matchGranularity = Math.min(that.MatchGranularityMaximum, Math.min(that._oldWords.length, that._newWords.length));\n\n        var operations = Operations();\n\n        for (var i = 0; i < operations.length; i++) {\n            PerformOperation(operations[i]);\n        }\n\n        return that._content.join('');\n    };\n\n    /// <summary>\n    /// Uses <paramref name=\"expression\"/> to group text together so that any change detected within the group is treated as a single block\n    /// </summary>\n    /// <param name=\"expression\"></param>\n    this.AddBlockExpression = function (expression) {\n        that._blockExpressions.push(expression);\n    };\n\n    var SplitInputsToWords = function SplitInputsToWords() {\n        that._oldWords = HtmlDiff.WordSplitter.ConvertHtmlToListOfWords(that._oldText, that._blockExpressions);\n        that._oldText = null;\n\n        that._newWords = HtmlDiff.WordSplitter.ConvertHtmlToListOfWords(that._newText, that._blockExpressions);\n        that._newText = null;\n    };\n\n    var PerformOperation = function PerformOperation(operation) {\n        switch (operation.Action) {\n            case HtmlDiff.Action.Equal:\n                ProcessEqualOperation(operation);\n                break;\n            case HtmlDiff.Action.Delete:\n                ProcessDeleteOperation(operation, 'diffdel');\n                break;\n            case HtmlDiff.Action.Insert:\n                ProcessInsertOperation(operation, 'diffins');\n                break;\n            case HtmlDiff.Action.None:\n                break;\n            case HtmlDiff.Action.Replace:\n                ProcessReplaceOperation(operation);\n                break;\n        }\n    };\n\n    var ProcessReplaceOperation = function ProcessReplaceOperation(operation) {\n        ProcessDeleteOperation(operation, 'diffmod');\n        ProcessInsertOperation(operation, 'diffmod');\n    };\n\n    var ProcessInsertOperation = function ProcessInsertOperation(operation, cssClass) {\n        InsertTag('ins', cssClass, that._newWords.slice(operation.StartInNew, operation.EndInNew));\n    };\n\n    var ProcessDeleteOperation = function ProcessDeleteOperation(operation, cssClass) {\n        InsertTag('del', cssClass, that._oldWords.slice(operation.StartInOld, operation.EndInOld));\n    };\n\n    var ProcessEqualOperation = function ProcessEqualOperation(operation) {\n        that._content.push(that._newWords.slice(operation.StartInNew, operation.EndInNew).join(''));\n    };\n\n    /// <summary>\n    ///     This method encloses words within a specified tag (ins or del), and adds this into \"content\",\n    ///     with a twist: if there are words contain tags, it actually creates multiple ins or del,\n    ///     so that they don't include any ins or del. This handles cases like\n    ///     old: '<p>a</p>'\n    ///     new: '<p>ab</p>\n    ///     <p>\n    ///         c</b>'\n    ///         diff result: '<p>a<ins>b</ins></p>\n    ///         <p>\n    ///             <ins>c</ins>\n    ///         </p>\n    ///         '\n    ///         this still doesn't guarantee valid HTML (hint: think about diffing a text containing ins or\n    ///         del tags), but handles correctly more cases than the earlier version.\n    ///         P.S.: Spare a thought for people who write HTML browsers. They live in this ... every day.\n    /// </summary>\n    /// <param name=\"tag\"></param>\n    /// <param name=\"cssClass\"></param>\n    /// <param name=\"words\"></param>\n    var InsertTag = function InsertTag(tag, cssClass, words) {\n        while (words.length > 0) {\n            var nonTags = ExtractConsecutiveWords(words, function (x) {\n                return !HtmlDiff.Utils.IsTag(x);\n            });\n\n            var specialCaseTagInjection = '';\n            var specialCaseTagInjectionIsBefore = false;\n\n            if (nonTags.length !== 0) {\n                var text = HtmlDiff.Utils.WrapText(nonTags.join(''), tag, cssClass);\n                that._content.push(text);\n            } else {\n                // Check if the tag is a special case\n                if (that._specialCaseOpeningTagRegex.test(words[0])) {\n                    that._specialTagDiffStack.push(words[0]);\n                    specialCaseTagInjection = '<ins class=\"mod\">';\n                    if (tag == 'del') {\n                        words.shift();\n\n                        // following tags may be formatting tags as well, follow through\n                        while (words.length > 0 && that._specialCaseOpeningTagRegex.test(words[0])) {\n                            words.shift();\n                        }\n                    }\n                } else if (that._specialCaseClosingTags.hasOwnProperty(words[0].toLowerCase())) {\n                    var openingTag = that._specialTagDiffStack.length === 0 ? null : that._specialTagDiffStack.pop();\n\n                    // If we didn't have an opening tag, and we don't have a match with the previous tag used \n                    if (openingTag === null || openingTag != words[words.length - 1].replace('/', '')) {\n                        // do nothing\n                    } else {\n                        specialCaseTagInjection = '</ins>';\n                        specialCaseTagInjectionIsBefore = true;\n                    }\n\n                    if (tag == 'del') {\n                        words.shift();\n\n                        // following tags may be formatting tags as well, follow through\n                        while (words.length > 0 && that._specialCaseClosingTags.hasOwnProperty(words[0].toLowerCase())) {\n                            words.shift();\n                        }\n                    }\n                }\n            }\n\n            if (words.length === 0 && specialCaseTagInjection.length === 0) {\n                break;\n            }\n\n            if (specialCaseTagInjectionIsBefore) {\n                that._content.push(specialCaseTagInjection + ExtractConsecutiveWords(words, HtmlDiff.Utils.IsTag).join(''));\n            } else {\n                that._content.push(ExtractConsecutiveWords(words, HtmlDiff.Utils.IsTag).join('') + specialCaseTagInjection);\n            }\n        }\n    };\n\n    var ExtractConsecutiveWords = function ExtractConsecutiveWords(words, condition) {\n        var indexOfFirstTag = null;\n\n        for (var i = 0; i < words.length; i++) {\n            var word = words[i];\n\n            if (i === 0 && word == ' ') {\n                words[i] = '&nbsp;';\n            }\n\n            if (!condition(word)) {\n                indexOfFirstTag = i;\n                break;\n            }\n        }\n\n        var items = void 0;\n        if (indexOfFirstTag !== null) {\n            items = words.slice(0, indexOfFirstTag);\n            if (indexOfFirstTag > 0) {\n                words.splice(0, indexOfFirstTag);\n            }\n        } else {\n            items = words.slice();\n            words.splice(0);\n        }\n\n        return items;\n    };\n\n    var Operations = function Operations() {\n        var positionInOld = 0,\n            positionInNew = 0;\n        var operations = [];\n\n        var matches = MatchingBlocks();\n\n        matches.push(new HtmlDiff.Match(that._oldWords.length, that._newWords.length, 0));\n\n        //Remove orphans from matches.\n        //If distance between left and right matches is 4 times longer than length of current match then it is considered as orphan\n        var mathesWithoutOrphans = RemoveOrphans(matches);\n\n        for (var i = 0; i < mathesWithoutOrphans.length; i++) {\n            var matchStartsAtCurrentPositionInOld = positionInOld == mathesWithoutOrphans[i].StartInOld;\n            var matchStartsAtCurrentPositionInNew = positionInNew == mathesWithoutOrphans[i].StartInNew;\n\n            var action = null;\n\n            if (matchStartsAtCurrentPositionInOld === false && matchStartsAtCurrentPositionInNew === false) {\n                action = HtmlDiff.Action.Replace;\n            } else if (matchStartsAtCurrentPositionInOld && matchStartsAtCurrentPositionInNew === false) {\n                action = HtmlDiff.Action.Insert;\n            } else if (matchStartsAtCurrentPositionInOld === false) {\n                action = HtmlDiff.Action.Delete;\n            } else // This occurs if the first few words are the same in both versions\n                {\n                    action = HtmlDiff.Action.None;\n                }\n\n            if (action != HtmlDiff.Action.None) {\n                operations.push(new HtmlDiff.Operation(action, positionInOld, mathesWithoutOrphans[i].StartInOld, positionInNew, mathesWithoutOrphans[i].StartInNew));\n            }\n\n            if (mathesWithoutOrphans[i].Size !== 0) {\n                operations.push(new HtmlDiff.Operation(HtmlDiff.Action.Equal, mathesWithoutOrphans[i].StartInOld, mathesWithoutOrphans[i].EndInOld(), mathesWithoutOrphans[i].StartInNew, mathesWithoutOrphans[i].EndInNew()));\n            }\n\n            positionInOld = mathesWithoutOrphans[i].EndInOld();\n            positionInNew = mathesWithoutOrphans[i].EndInNew();\n        }\n\n        return operations;\n    };\n\n    var RemoveOrphans = function RemoveOrphans(matches) {\n        var matchesNoOrphans = [];\n        var prev = null;\n        var curr = null;\n        for (var i = 0; i < matches.length; i++) {\n            if (curr === null) {\n                prev = new HtmlDiff.Match(0, 0, 0);\n                curr = matches[i];\n                continue;\n            }\n\n            //if match has no diff on the left or on the right\n            if (prev.EndInOld() == curr.StartInOld && prev.EndInNew() == curr.StartInNew || curr.EndInOld() == matches[i].StartInOld && curr.EndInNew() == matches[i].StartInNew) {\n                matchesNoOrphans.push(new HtmlDiff.Match(curr.StartInOld, curr.StartInNew, curr.Size));\n                prev = curr;\n                curr = matches[i];\n                continue;\n            }\n\n            var j = void 0;\n            var oldDistanceInChars = 0;\n            for (j = Math.min(prev.EndInOld(), matches[i].StartInOld - prev.EndInOld()); j < Math.max(prev.EndInOld(), matches[i].StartInOld - prev.EndInOld()); j++) {\n                oldDistanceInChars += that._oldWords[j].length;\n            }\n\n            var newDistanceInChars = 0;\n            for (j = Math.min(prev.EndInNew(), matches[i].StartInNew - prev.EndInNew()); j < Math.max(prev.EndInNew(), matches[i].StartInNew - prev.EndInNew()); j++) {\n                newDistanceInChars += that._newWords[j].length;\n            }\n\n            var currMatchLengthInChars = 0;\n            for (j = Math.min(curr.StartInNew, curr.EndInNew() - curr.StartInNew); j < Math.max(curr.StartInNew, curr.EndInNew() - curr.StartInNew); j++) {\n                currMatchLengthInChars += that._newWords[j].length;\n            }\n\n            if (currMatchLengthInChars > Math.max(oldDistanceInChars, newDistanceInChars) * that.OrphanMatchThreshold) {\n                matchesNoOrphans.push(new HtmlDiff.Match(curr.StartInOld, curr.StartInNew, curr.Size));\n            }\n\n            prev = curr;\n            curr = matches[i];\n        }\n\n        matchesNoOrphans.push(new HtmlDiff.Match(curr.StartInOld, curr.StartInNew, curr.Size));\n        return matchesNoOrphans;\n    };\n\n    var MatchingBlocks = function MatchingBlocks() {\n        var matchingBlocks = [];\n        FindMatchingBlocks(0, that._oldWords.length, 0, that._newWords.length, matchingBlocks);\n        return matchingBlocks;\n    };\n\n    var FindMatchingBlocks = function FindMatchingBlocks(startInOld, endInOld, startInNew, endInNew, matchingBlocks) {\n        var match = FindMatch(startInOld, endInOld, startInNew, endInNew);\n\n        if (match !== null) {\n            if (startInOld < match.StartInOld && startInNew < match.StartInNew) {\n                FindMatchingBlocks(startInOld, match.StartInOld, startInNew, match.StartInNew, matchingBlocks);\n            }\n\n            matchingBlocks.push(match);\n\n            if (match.EndInOld() < endInOld && match.EndInNew() < endInNew) {\n                FindMatchingBlocks(match.EndInOld(), endInOld, match.EndInNew(), endInNew, matchingBlocks);\n            }\n        }\n    };\n\n    var FindMatch = function FindMatch(startInOld, endInOld, startInNew, endInNew) {\n        // For large texts it is more likely that there is a Match of size bigger than maximum granularity.\n        // If not then go down and try to find it with smaller granularity.\n        for (var i = that._matchGranularity; i > 0; i--) {\n            var options = new HtmlDiff.MatchOptions();\n            options.BlockSize = i;\n            options.RepeatingWordsAccuracy = that.RepeatingWordsAccuracy;\n            options.IgnoreWhitespaceDifferences = that.IgnoreWhitespaceDifferences;\n\n            var finder = new HtmlDiff.MatchFinder(that._oldWords, that._newWords, startInOld, endInOld, startInNew, endInNew, options);\n            var match = finder.FindMatch();\n            if (match !== null) {\n                return match;\n            }\n        }\n\n        return null;\n    };\n};\n\n/* STATIC OBJECTS */\n\nHtmlDiff.Action = {\n    Equal: 0,\n    Delete: 1,\n    Insert: 2,\n    None: 3,\n    Replace: 4\n};\n\nHtmlDiff.Mode = {\n    Character: 0,\n    Tag: 1,\n    Whitespace: 2,\n    Entity: 3\n};\n\nHtmlDiff.Utils = {\n    OpeningTagRegex: new RegExp(/^\\s*<[^>]+>\\s*$/),\n    ClosingTagTexRegex: new RegExp(/^\\s*<\\/[^>]+>\\s*$/),\n    TagWordRegex: new RegExp(/<[^\\s>]+/),\n    WhitespaceRegex: new RegExp(/^(\\s|&nbsp;)+$/),\n    WordRegex: new RegExp(/[\\w#@]+/),\n    SpecialCaseWordTags: ['<img'],\n    IsTag: function IsTag(item) {\n        for (var i = 0; i < HtmlDiff.Utils.SpecialCaseWordTags.length; i++) {\n            if (item !== null && item.startsWith(HtmlDiff.Utils.SpecialCaseWordTags[i])) {\n                return false;\n            }\n        }\n\n        return HtmlDiff.Utils.IsOpeningTag(item) || HtmlDiff.Utils.IsClosingTag(item);\n    },\n    IsOpeningTag: function IsOpeningTag(item) {\n        return HtmlDiff.Utils.OpeningTagRegex.test(item);\n    },\n    IsClosingTag: function IsClosingTag(item) {\n        return HtmlDiff.Utils.ClosingTagTexRegex.test(item);\n    },\n    StripTagAttributes: function StripTagAttributes(word) {\n        var matches = word.match(HtmlDiff.Utils.TagWordRegex);\n        var tag = matches.length > 0 ? matches[0] : '';\n        word = tag + (word.endsWith('/>') ? '/>' : '>');\n        return word;\n    },\n    WrapText: function WrapText(text, tagName, cssClass) {\n        return '<' + tagName + ' class=\"' + cssClass + '\">' + text + '</' + tagName + '>';\n    },\n    IsStartOfTag: function IsStartOfTag(val) {\n        return val == '<';\n    },\n    IsEndOfTag: function IsEndOfTag(val) {\n        return val == '>';\n    },\n    IsStartOfEntity: function IsStartOfEntity(val) {\n        return val == '&';\n    },\n    IsEndOfEntity: function IsEndOfEntity(val) {\n        return val == ';';\n    },\n    IsWhiteSpace: function IsWhiteSpace(value) {\n        return HtmlDiff.Utils.WhitespaceRegex.test(value);\n    },\n    StripAnyAttributes: function StripAnyAttributes(word) {\n        if (HtmlDiff.Utils.IsTag(word)) {\n            return HtmlDiff.Utils.StripTagAttributes(word);\n        }\n\n        return word;\n    },\n    IsWord: function IsWord(text) {\n        return HtmlDiff.Utils.WordRegex.test(text);\n    }\n};\n\nHtmlDiff.WordSplitter = {\n    ConvertHtmlToListOfWords: function ConvertHtmlToListOfWords(text, blockExpressions) {\n        var mode = HtmlDiff.Mode.Character;\n        var currentWord = []; // new List<char>();\n        var words = []; // new List<string>();\n\n        var blockLocations = HtmlDiff.WordSplitter.FindBlocks(text, blockExpressions);\n\n        var isBlockCheckRequired = blockLocations.length > 0;\n        var isGrouping = false;\n        var groupingUntil = -1;\n\n        for (var index = 0; index < text.length; index++) {\n            var character = text[index];\n\n            // Don't bother executing block checks if we don't have any blocks to check for!\n            if (isBlockCheckRequired) {\n                // Check if we have completed grouping a text sequence/block\n                if (groupingUntil == index) {\n                    groupingUntil = -1;\n                    isGrouping = false;\n                }\n\n                // Check if we need to group the next text sequence/block\n                if (blockLocations.hasOwnProperty(index)) {\n                    isGrouping = true;\n                    groupingUntil = blockLocations[index];\n                }\n\n                // if we are grouping, then we don't care about what type of character we have, it's going to be treated as a word\n                if (isGrouping) {\n                    currentWord.push(character);\n                    mode = HtmlDiff.Mode.Character;\n                    continue;\n                }\n            }\n\n            switch (mode) {\n                case HtmlDiff.Mode.Character:\n\n                    if (HtmlDiff.Utils.IsStartOfTag(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push('<');\n                        mode = HtmlDiff.Mode.Tag;\n                    } else if (HtmlDiff.Utils.IsStartOfEntity(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Entity;\n                    } else if (HtmlDiff.Utils.IsWhiteSpace(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Whitespace;\n                    } else if (HtmlDiff.Utils.IsWord(character) && (currentWord.length === 0 || HtmlDiff.Utils.IsWord(currentWord[currentWord.length - 1]))) {\n                        currentWord.push(character);\n                    } else {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n                        currentWord = [];\n                        currentWord.push(character);\n                    }\n\n                    break;\n                case HtmlDiff.Mode.Tag:\n\n                    if (HtmlDiff.Utils.IsEndOfTag(character)) {\n                        currentWord.push(character);\n                        words.push(currentWord.join(''));\n                        currentWord = [];\n\n                        mode = HtmlDiff.Utils.IsWhiteSpace(character) ? HtmlDiff.Mode.Whitespace : HtmlDiff.Mode.Character;\n                    } else {\n                        currentWord.push(character);\n                    }\n\n                    break;\n                case HtmlDiff.Mode.Whitespace:\n\n                    if (HtmlDiff.Utils.IsStartOfTag(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Tag;\n                    } else if (HtmlDiff.Utils.IsStartOfEntity(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Entity;\n                    } else if (HtmlDiff.Utils.IsWhiteSpace(character)) {\n                        currentWord.push(character);\n                    } else {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Character;\n                    }\n\n                    break;\n                case HtmlDiff.Mode.Entity:\n                    if (HtmlDiff.Utils.IsStartOfTag(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Tag;\n                    } else if (HtmlDiff.Utils.IsWhiteSpace(character)) {\n                        if (currentWord.length !== 0) {\n                            words.push(currentWord.join(''));\n                        }\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Whitespace;\n                    } else if (HtmlDiff.Utils.IsEndOfEntity(character)) {\n                        var switchToNextMode = true;\n                        if (currentWord.length != 0) {\n                            currentWord.push(character);\n                            words.push(currentWord.join(''));\n\n                            //join &nbsp; entity with last whitespace\n                            if (words.length > 2 && HtmlDiff.Utils.IsWhiteSpace(words[words.length - 2]) && HtmlDiff.Utils.IsWhiteSpace(words[words.length - 1])) {\n                                var w1 = words[words.length - 2];\n                                var w2 = words[words.length - 1];\n\n                                words.pop();\n                                words.pop();\n                                currentWord = [];\n\n                                currentWord.concat(w1.split(''));\n                                currentWord.concat(w2.split(''));\n                                mode = HtmlDiff.Mode.Whitespace;\n                                switchToNextMode = false;\n                            }\n                        }\n\n                        if (switchToNextMode) {\n                            currentWord = [];\n                            mode = HtmlDiff.Mode.Character;\n                        }\n                    } else if (HtmlDiff.Utils.IsWord(character)) {\n                        currentWord.push(character);\n                    } else {\n                        if (currentWord.length != 0) {\n                            words.push(currentWord.join(''));\n                        }\n\n                        currentWord = [];\n                        currentWord.push(character);\n                        mode = HtmlDiff.Mode.Character;\n                    }\n                    break;\n            }\n        }\n        if (currentWord.length != 0) {\n            words.push(currentWord.join(''));\n        }\n\n        return words;\n    },\n    FindBlocks: function FindBlocks(text, blockExpressions) {\n        var blockLocations = {}; // new Dictionary<int, int>();\n\n        if (blockExpressions == null) {\n            return blockLocations;\n        }\n\n        for (var i = 0; i < blockExpressions.length; i++) {\n            var matches = text.match(blockExpressions[i]);\n            var matchEnd = 0;\n            for (var j = 0; j < matches.length; j++) {\n                var index = text.indexOf(matches[j], matchEnd);\n                blockLocations.Add(index, index + matches[j].length);\n                matchEnd = index + matches[j].length;\n            }\n        }\n\n        return blockLocations;\n    }\n};\n\n/* INSTANTIATED OBJECTS */\n\nHtmlDiff.Match = function (startInOld, startInNew, size) {\n    this.StartInOld = startInOld;\n    this.StartInNew = startInNew;\n    this.Size = size;\n    this.EndInOld = function () {\n        return this.StartInOld + this.Size;\n    };\n    this.EndInNew = function () {\n        return this.StartInNew + this.Size;\n    };\n};\n\nHtmlDiff.Operation = function (action, startInOld, endInOld, startInNew, endInNew) {\n    this.Action = action;\n    this.StartInOld = startInOld;\n    this.EndInOld = endInOld;\n    this.StartInNew = startInNew;\n    this.EndInNew = endInNew;\n};\n\nHtmlDiff.MatchOptions = function () {\n    this.BlockSize = 0;\n    this.RepeatingWordsAccuracy = 0;\n    this.IgnoreWhitespaceDifferences = false;\n};\n\nHtmlDiff.MatchFinder = function (oldWords, newWords, startInOld, endInOld, startInNew, endInNew, options) {\n    this._oldWords = oldWords;\n    this._newWords = newWords;\n    this._startInOld = startInOld;\n    this._endInOld = endInOld;\n    this._startInNew = startInNew;\n    this._endInNew = endInNew;\n    this._wordIndices = null;\n    this._options = options;\n    var that = this;\n\n    this.IndexNewWords = function () {\n        that._wordIndices = {}; // new Dictionary<string, List<int>>();\n        var block = []; // new Queue<string>(_options.BlockSize);\n        for (var i = that._startInNew; i < that._endInNew; i++) {\n\n            // if word is a tag, we should ignore attributes as attribute changes are not supported (yet)\n            var word = that.NormalizeForIndex(that._newWords[i]);\n            var key = that.PutNewWord(block, word, that._options.BlockSize);\n\n            if (key == null) {\n                continue;\n            }\n\n            if (that._wordIndices.hasOwnProperty(key)) {\n                that._wordIndices[key].push(i);\n            } else {\n                that._wordIndices[key] = [i];\n            }\n        }\n    };\n\n    this.PutNewWord = function (block, word, blockSize) {\n        block.push(word);\n        if (block.length > blockSize) {\n            block.shift();\n        }\n\n        if (block.length != blockSize) {\n            return null;\n        }\n\n        var result = '';\n        for (var i = 0; i < block.length; i++) {\n            result += block[i];\n        }\n\n        return result;\n    };\n\n    this.NormalizeForIndex = function (word) {\n        word = HtmlDiff.Utils.StripAnyAttributes(word);\n        if (that._options.IgnoreWhitespaceDifferences && HtmlDiff.Utils.IsWhiteSpace(word)) {\n            return ' ';\n        }\n\n        return word;\n    };\n\n    this.FindMatch = function () {\n        that.IndexNewWords();\n        that.RemoveRepeatingWords();\n\n        if (that._wordIndices.length == 0) {\n            return null;\n        }\n\n        var bestMatchInOld = that._startInOld;\n        var bestMatchInNew = that._startInNew;\n        var bestMatchSize = 0;\n\n        var matchLengthAt = {}; //new Dictionary<int, int>();\n        var block = []; //new Queue<string>(_options.BlockSize);\n\n        for (var indexInOld = that._startInOld; indexInOld < that._endInOld; indexInOld++) {\n            var word = that.NormalizeForIndex(that._oldWords[indexInOld]);\n            var index = that.PutNewWord(block, word, that._options.BlockSize);\n\n            if (index == null) {\n                continue;\n            }\n\n            var newMatchLengthAt = {}; //new Dictionary<int, int>();\n\n            if (!that._wordIndices.hasOwnProperty(index)) {\n                matchLengthAt = newMatchLengthAt;\n                continue;\n            }\n\n            for (var i = 0; i < that._wordIndices[index].length; i++) {\n                var newMatchLength = (matchLengthAt.hasOwnProperty(that._wordIndices[index][i] - 1) ? matchLengthAt[that._wordIndices[index][i] - 1] : 0) + 1;\n                newMatchLengthAt[that._wordIndices[index][i]] = newMatchLength;\n\n                if (newMatchLength > bestMatchSize) {\n                    bestMatchInOld = indexInOld - newMatchLength + 1 - that._options.BlockSize + 1;\n                    bestMatchInNew = that._wordIndices[index][i] - newMatchLength + 1 - that._options.BlockSize + 1;\n                    bestMatchSize = newMatchLength;\n                }\n            }\n\n            matchLengthAt = newMatchLengthAt;\n        }\n\n        return bestMatchSize != 0 ? new HtmlDiff.Match(bestMatchInOld, bestMatchInNew, bestMatchSize + that._options.BlockSize - 1) : null;\n    };\n\n    this.RemoveRepeatingWords = function () {\n        var threshold = that._newWords.length * that._options.RepeatingWordsAccuracy;\n        var repeatingWords = [];\n        for (var w in that._wordIndices) {\n            if (!that._wordIndices.hasOwnProperty(w)) {\n                continue;\n            }\n\n            if (that._wordIndices[w].length > threshold) {\n                repeatingWords.push(w);\n            }\n        }\n\n        for (var i = 0; i < repeatingWords.length; i++) {\n            delete that._wordIndices[repeatingWords[i]];\n        }\n    };\n};\n\nexports.default = HtmlDiff;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IdG1sRGlmZi8uL2luZGV4LmpzPzQxZjUiXSwibmFtZXMiOlsiSHRtbERpZmYiLCJvbGRUZXh0IiwibmV3VGV4dCIsIk1hdGNoR3JhbnVsYXJpdHlNYXhpbXVtIiwiX2NvbnRlbnQiLCJfbmV3VGV4dCIsIl9vbGRUZXh0IiwidGhhdCIsIl9zcGVjaWFsQ2FzZUNsb3NpbmdUYWdzIiwiX3NwZWNpYWxDYXNlT3BlbmluZ1RhZ1JlZ2V4IiwiUmVnRXhwIiwiX3NwZWNpYWxUYWdEaWZmU3RhY2siLCJfbmV3V29yZHMiLCJfb2xkV29yZHMiLCJfbWF0Y2hHcmFudWxhcml0eSIsIl9ibG9ja0V4cHJlc3Npb25zIiwiUmVwZWF0aW5nV29yZHNBY2N1cmFjeSIsIklnbm9yZVdoaXRlc3BhY2VEaWZmZXJlbmNlcyIsIk9ycGhhbk1hdGNoVGhyZXNob2xkIiwiQnVpbGQiLCJTcGxpdElucHV0c1RvV29yZHMiLCJNYXRoIiwibWluIiwibGVuZ3RoIiwib3BlcmF0aW9ucyIsIk9wZXJhdGlvbnMiLCJpIiwiUGVyZm9ybU9wZXJhdGlvbiIsImpvaW4iLCJBZGRCbG9ja0V4cHJlc3Npb24iLCJleHByZXNzaW9uIiwicHVzaCIsIldvcmRTcGxpdHRlciIsIkNvbnZlcnRIdG1sVG9MaXN0T2ZXb3JkcyIsIm9wZXJhdGlvbiIsIkFjdGlvbiIsIkVxdWFsIiwiUHJvY2Vzc0VxdWFsT3BlcmF0aW9uIiwiRGVsZXRlIiwiUHJvY2Vzc0RlbGV0ZU9wZXJhdGlvbiIsIkluc2VydCIsIlByb2Nlc3NJbnNlcnRPcGVyYXRpb24iLCJOb25lIiwiUmVwbGFjZSIsIlByb2Nlc3NSZXBsYWNlT3BlcmF0aW9uIiwiY3NzQ2xhc3MiLCJJbnNlcnRUYWciLCJzbGljZSIsIlN0YXJ0SW5OZXciLCJFbmRJbk5ldyIsIlN0YXJ0SW5PbGQiLCJFbmRJbk9sZCIsInRhZyIsIndvcmRzIiwibm9uVGFncyIsIkV4dHJhY3RDb25zZWN1dGl2ZVdvcmRzIiwieCIsIlV0aWxzIiwiSXNUYWciLCJzcGVjaWFsQ2FzZVRhZ0luamVjdGlvbiIsInNwZWNpYWxDYXNlVGFnSW5qZWN0aW9uSXNCZWZvcmUiLCJ0ZXh0IiwiV3JhcFRleHQiLCJ0ZXN0Iiwic2hpZnQiLCJoYXNPd25Qcm9wZXJ0eSIsInRvTG93ZXJDYXNlIiwib3BlbmluZ1RhZyIsInBvcCIsInJlcGxhY2UiLCJjb25kaXRpb24iLCJpbmRleE9mRmlyc3RUYWciLCJ3b3JkIiwiaXRlbXMiLCJzcGxpY2UiLCJwb3NpdGlvbkluT2xkIiwicG9zaXRpb25Jbk5ldyIsIm1hdGNoZXMiLCJNYXRjaGluZ0Jsb2NrcyIsIk1hdGNoIiwibWF0aGVzV2l0aG91dE9ycGhhbnMiLCJSZW1vdmVPcnBoYW5zIiwibWF0Y2hTdGFydHNBdEN1cnJlbnRQb3NpdGlvbkluT2xkIiwibWF0Y2hTdGFydHNBdEN1cnJlbnRQb3NpdGlvbkluTmV3IiwiYWN0aW9uIiwiT3BlcmF0aW9uIiwiU2l6ZSIsIm1hdGNoZXNOb09ycGhhbnMiLCJwcmV2IiwiY3VyciIsImoiLCJvbGREaXN0YW5jZUluQ2hhcnMiLCJtYXgiLCJuZXdEaXN0YW5jZUluQ2hhcnMiLCJjdXJyTWF0Y2hMZW5ndGhJbkNoYXJzIiwibWF0Y2hpbmdCbG9ja3MiLCJGaW5kTWF0Y2hpbmdCbG9ja3MiLCJzdGFydEluT2xkIiwiZW5kSW5PbGQiLCJzdGFydEluTmV3IiwiZW5kSW5OZXciLCJtYXRjaCIsIkZpbmRNYXRjaCIsIm9wdGlvbnMiLCJNYXRjaE9wdGlvbnMiLCJCbG9ja1NpemUiLCJmaW5kZXIiLCJNYXRjaEZpbmRlciIsIk1vZGUiLCJDaGFyYWN0ZXIiLCJUYWciLCJXaGl0ZXNwYWNlIiwiRW50aXR5IiwiT3BlbmluZ1RhZ1JlZ2V4IiwiQ2xvc2luZ1RhZ1RleFJlZ2V4IiwiVGFnV29yZFJlZ2V4IiwiV2hpdGVzcGFjZVJlZ2V4IiwiV29yZFJlZ2V4IiwiU3BlY2lhbENhc2VXb3JkVGFncyIsIml0ZW0iLCJzdGFydHNXaXRoIiwiSXNPcGVuaW5nVGFnIiwiSXNDbG9zaW5nVGFnIiwiU3RyaXBUYWdBdHRyaWJ1dGVzIiwiZW5kc1dpdGgiLCJ0YWdOYW1lIiwiSXNTdGFydE9mVGFnIiwidmFsIiwiSXNFbmRPZlRhZyIsIklzU3RhcnRPZkVudGl0eSIsIklzRW5kT2ZFbnRpdHkiLCJJc1doaXRlU3BhY2UiLCJ2YWx1ZSIsIlN0cmlwQW55QXR0cmlidXRlcyIsIklzV29yZCIsImJsb2NrRXhwcmVzc2lvbnMiLCJtb2RlIiwiY3VycmVudFdvcmQiLCJibG9ja0xvY2F0aW9ucyIsIkZpbmRCbG9ja3MiLCJpc0Jsb2NrQ2hlY2tSZXF1aXJlZCIsImlzR3JvdXBpbmciLCJncm91cGluZ1VudGlsIiwiaW5kZXgiLCJjaGFyYWN0ZXIiLCJzd2l0Y2hUb05leHRNb2RlIiwidzEiLCJ3MiIsImNvbmNhdCIsInNwbGl0IiwibWF0Y2hFbmQiLCJpbmRleE9mIiwiQWRkIiwic2l6ZSIsIm9sZFdvcmRzIiwibmV3V29yZHMiLCJfc3RhcnRJbk9sZCIsIl9lbmRJbk9sZCIsIl9zdGFydEluTmV3IiwiX2VuZEluTmV3IiwiX3dvcmRJbmRpY2VzIiwiX29wdGlvbnMiLCJJbmRleE5ld1dvcmRzIiwiYmxvY2siLCJOb3JtYWxpemVGb3JJbmRleCIsImtleSIsIlB1dE5ld1dvcmQiLCJibG9ja1NpemUiLCJyZXN1bHQiLCJSZW1vdmVSZXBlYXRpbmdXb3JkcyIsImJlc3RNYXRjaEluT2xkIiwiYmVzdE1hdGNoSW5OZXciLCJiZXN0TWF0Y2hTaXplIiwibWF0Y2hMZW5ndGhBdCIsImluZGV4SW5PbGQiLCJuZXdNYXRjaExlbmd0aEF0IiwibmV3TWF0Y2hMZW5ndGgiLCJ0aHJlc2hvbGQiLCJyZXBlYXRpbmdXb3JkcyIsInciXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7Ozs7Ozs7Ozs7QUFVQSxJQUFNQSxXQUFXLFNBQVhBLFFBQVcsQ0FBVUMsT0FBVixFQUFtQkMsT0FBbkIsRUFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBS0MsdUJBQUwsR0FBK0IsQ0FBL0I7O0FBRUEsU0FBS0MsUUFBTCxHQUFnQixFQUFoQjtB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TCxDQUFrQi9GLGNBQWxCLENBQWlDa0gsQ0FBakMsQ0FBTCxFQUEwQztBQUN0QztBQUNIOztBQUVELGdCQUFJNUssS0FBS3lKLFlBQUwsQ0FBa0JtQixDQUFsQixFQUFxQjVKLE1BQXJCLEdBQThCMEosU0FBbEMsRUFBNkM7QUFDekNDLCtCQUFlbkosSUFBZixDQUFvQm9KLENBQXBCO0FBQ0g7QUFDSjs7QUFFRCxhQUFLLElBQUl6SixJQUFJLENBQWIsRUFBZ0JBLElBQUl3SixlQUFlM0osTUFBbkMsRUFBMkNHLEdBQTNDLEVBQWdEO0FBQzVDLG1CQUFPbkIsS0FBS3lKLFlBQUwsQ0FBa0JrQixlQUFleEosQ0FBZixDQUFsQixDQUFQO0FBQ0g7QUFDSixLQWhCRDtBQWlCSCxDQTVIRDs7a0JBOEhlMUIsUSIsImZpbGUiOiIuL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuXHJcbk1hbnVhbGx5IHRyYW5zbGF0ZWQgdG8gSlMgZnJvbSBDIy5cclxuT3JpZ2luYWw6IGh0dHBzOi8vZ2l0aHViLmNvbS9Sb2hsYW5kL2h0bWxkaWZmLm5ldFxyXG5PcmlnaW5hbCB3YXMgYWN0dWFsbHkgYSAubmV0IHBvcnQgb2YgYSBSdWJ5IGltcGxlbWVudGF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vbXlvYmllL2h0bWxkaWZmXHJcblRoZXJlIGFsc28gbG9va3MgdG8gYmUgb3RoZXIgaW1wbGVtZW50YXRpb25zIGluIENvZmZlZVNjcmlwdCwgYXMgd2VsbCBhcyBhbiBBbmd1bGFyIG1vZHVsZS5cclxuXHJcbiovXHJcblxyXG5cclxuY29uc3QgSHRtbERpZmYgPSBmdW5jdGlvbiAob2xkVGV4dCwgbmV3VGV4dCkge1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgdmFsdWUgZGVmaW5lcyBiYWxhbmNlIGJldHdlZW4gc3BlZWQgYW5kIG1lbW9yeSB1dGlsaXphdGlvbi4gVGhlIGhpZ2hlciBpdCBpcyB0aGUgZmFzdGVyIGl0IHdvcmtzIGFuZCBtb3JlIG1lbW9yeSBjb25zdW1lcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICB0aGlzLk1hdGNoR3JhbnVsYXJpdHlNYXhpbXVtID0gNDtcclxuXHJcbiAgICB0aGlzLl9jb250ZW50ID0gW107XHJcbiAgICB0aGlzLl9uZXdUZXh0ID0gbmV3VGV4dDtcclxuICAgIHRoaXMuX29sZFRleHQgPSBvbGRUZXh0O1xyXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5fc3BlY2lhbENhc2VDbG9zaW5nVGFncyA9IHtcclxuICAgICAgICAnPC9zdHJvbmc+JzogMCxcclxuICAgICAgICAnPC9lbT4nOiAwLFxyXG4gICAgICAgICc8L2I+JzogMCxcclxuICAgICAgICAnPC9pPic6IDAsXHJcbiAgICAgICAgJzwvYmlnPic6IDAsXHJcbiAgICAgICAgJzwvc21hbGw+JzogMCxcclxuICAgICAgICAnPC91Pic6IDAsXHJcbiAgICAgICAgJzwvc3ViPic6IDAsXHJcbiAgICAgICAgJzwvc3VwPic6IDAsXHJcbiAgICAgICAgJzwvc3RyaWtlPic6IDAsXHJcbiAgICAgICAgJzwvcz4nOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3NwZWNpYWxDYXNlT3BlbmluZ1RhZ1JlZ2V4ID0gbmV3IFJlZ0V4cCgvPCgoc3Ryb25nKXwoYil8KGkpfChlbSl8KGJpZyl8KHNtYWxsKXwodSl8KHN1Yil8KHN1cCl8KHN0cmlrZSl8KHMpKVs+XFxzXSsvaSk7XHJcblxyXG4gICAgdGhpcy5fc3BlY2lhbFRhZ0RpZmZTdGFjayA9IFtdO1xyXG5cclxuICAgIHRoaXMuX25ld1dvcmRzO1xyXG4gICAgdGhpcy5fb2xkV29yZHM7XHJcbiAgICB0aGlzLl9tYXRjaEdyYW51bGFyaXR5O1xyXG4gICAgdGhpcy5fYmxvY2tFeHByZXNzaW9ucyA9IFtdO1xyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBEZWZpbmVzIGhvdyB0byBjb21wYXJlIHJlcGVhdGluZyB3b3Jkcy4gVmFsaWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gMS5cclxuICAgIC8vLyBUaGlzIHZhbHVlIGFsbG93cyB0byBleGNsdWRlIHNvbWUgd29yZHMgZnJvbSBjb21wYXJpc29uIHRoYXQgZXZlbnR1YWxseVxyXG4gICAgLy8vIHJlZHVjZXMgdGhlIHRvdGFsIHRpbWUgb2YgdGhlIGRpZmYgYWxnb3JpdGhtLlxyXG4gICAgLy8vIDAgbWVhbnMgdGhhdCBhbGwgd29yZHMgYXJlIGV4Y2x1ZGVkIHNvIHRoZSBkaWZmIHdpbGwgbm90IGZpbmQgYW55IG1hdGNoaW5nIHdvcmRzIGF0IGFsbC5cclxuICAgIC8vLyAxIChkZWZhdWx0IHZhbHVlKSBtZWFucyB0aGF0IGFsbCB3b3JkcyBwYXJ0aWNpcGF0ZSBpbiBjb21wYXJpc29uIHNvIHRoaXMgaXMgdGhlIG1vc3QgYWNjdXJhdGUgY2FzZS5cclxuICAgIC8vLyAwLjUgbWVhbnMgdGhhdCBhbnkgd29yZCB0aGF0IG9jY3VycyBtb3JlIHRoYW4gNTAlIHRpbWVzIG1heSBiZSBleGNsdWRlZCBmcm9tIGNvbXBhcmlzb24uIFRoaXMgZG9lc24ndFxyXG4gICAgLy8vIG1lYW4gdGhhdCBzdWNoIHdvcmRzIHdpbGwgZGVmaW5pdGVseSBiZSBleGNsdWRlZCBidXQgb25seSBnaXZlcyBhIHBlcm1pc3Npb24gdG8gZXhjbHVkZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICB0aGlzLlJlcGVhdGluZ1dvcmRzQWNjdXJhY3kgPSAxO1xyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBJZiB0cnVlIGFsbCB3aGl0ZXNwYWNlcyBhcmUgY29uc2lkZXJlZCBhcyBlcXVhbFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHRoaXMuSWdub3JlV2hpdGVzcGFjZURpZmZlcmVuY2VzID0gZmFsc2U7XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIElmIHNvbWUgbWF0Y2ggaXMgdG9vIHNtYWxsIGFuZCBsb2NhdGVkIGZhciBmcm9tIGl0cyBuZWlnaGJvcnMgdGhlbiBpdCBpcyBjb25zaWRlcmVkIGFzIG9ycGhhblxyXG4gICAgLy8vIGFuZCByZW1vdmVkLiBGb3IgZXhhbXBsZTpcclxuICAgIC8vLyA8Y29kZT5cclxuICAgIC8vLyBhYWFhYSBiYiBjY2NjY2NjY2MgZGRkZGRkIGVlXHJcbiAgICAvLy8gMTExMTEgYmIgMjIyMjIyMjIyIGRkZGRkZCBlZVxyXG4gICAgLy8vIDwvY29kZT5cclxuICAgIC8vLyB3aWxsIGZpbmQgdHdvIG1hdGNoZXMgPGNvZGU+YmI8L2NvZGU+IGFuZCA8Y29kZT5kZGRkZGQgZWU8L2NvZGU+IGJ1dCB0aGUgZmlyc3Qgd2lsbCBiZSBjb25zaWRlcmVkXHJcbiAgICAvLy8gYXMgb3JwaGFuIGFuZCBpZ25vcmVkLCBhcyByZXN1bHQgaXQgd2lsbCBjb25zaWRlciB0ZXh0cyA8Y29kZT5hYWFhYSBiYiBjY2NjY2NjY2M8L2NvZGU+IGFuZFxyXG4gICAgLy8vIDxjb2RlPjExMTExIGJiIDIyMjIyMjIyMjwvY29kZT4gYXMgc2luZ2xlIHJlcGxhY2VtZW50OlxyXG4gICAgLy8vIDxjb2RlPlxyXG4gICAgLy8vICZsdDtkZWwmZ3Q7YWFhYWEgYmIgY2NjY2NjY2NjJmx0Oy9kZWwmZ3Q7Jmx0O2lucyZndDsxMTExMSBiYiAyMjIyMjIyMjImbHQ7L2lucyZndDsgZGRkZGRkIGVlXHJcbiAgICAvLy8gPC9jb2RlPlxyXG4gICAgLy8vIFRoaXMgcHJvcGVydHkgZGVmaW5lcyByZWxhdGl2ZSBzaXplIG9mIHRoZSBtYXRjaCB0byBiZSBjb25zaWRlcmVkIGFzIG9ycGhhbiwgZnJvbSAwIHRvIDEuXHJcbiAgICAvLy8gMSBtZWFucyB0aGF0IGFsbCBtYXRjaGVzIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBvcnBoYW5zLlxyXG4gICAgLy8vIDAgKGRlZmF1bHQpIG1lYW5zIHRoYXQgbm8gbWF0Y2ggd2lsbCBiZSBjb25zaWRlcmVkIGFzIG9ycGhhbi5cclxuICAgIC8vLyAwLjIgbWVhbnMgdGhhdCBpZiBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIwJSBvZiBkaXN0YW5jZSBiZXR3ZWVuIGl0cyBuZWlnaGJvcnMgaXQgaXMgY29uc2lkZXJlZCBhcyBvcnBoYW4uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgdGhpcy5PcnBoYW5NYXRjaFRocmVzaG9sZCA9IDA7XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEJ1aWxkcyB0aGUgSFRNTCBkaWZmIG91dHB1dFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmV0dXJucz5IVE1MIGRpZmYgbWFya3VwPC9yZXR1cm5zPlxyXG4gICAgdGhpcy5CdWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBkaWZmZXJlbmNlLCBkb24ndCBib3RoZXIgY2hlY2tpbmcgZm9yIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgaWYgKHRoYXQuX29sZFRleHQgPT0gdGhhdC5fbmV3VGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5fbmV3VGV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFNwbGl0SW5wdXRzVG9Xb3JkcygpO1xyXG5cclxuICAgICAgICB0aGF0Ll9tYXRjaEdyYW51bGFyaXR5ID0gTWF0aC5taW4odGhhdC5NYXRjaEdyYW51bGFyaXR5TWF4aW11bSwgTWF0aC5taW4odGhhdC5fb2xkV29yZHMubGVuZ3RoLCB0aGF0Ll9uZXdXb3Jkcy5sZW5ndGgpKTtcclxuXHJcbiAgICAgICAgbGV0IG9wZXJhdGlvbnMgPSBPcGVyYXRpb25zKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBQZXJmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbnNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoYXQuX2NvbnRlbnQuam9pbignJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBVc2VzIDxwYXJhbXJlZiBuYW1lPVwiZXhwcmVzc2lvblwiLz4gdG8gZ3JvdXAgdGV4dCB0b2dldGhlciBzbyB0aGF0IGFueSBjaGFuZ2UgZGV0ZWN0ZWQgd2l0aGluIHRoZSBncm91cCBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIGJsb2NrXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwcmVzc2lvblwiPjwvcGFyYW0+XHJcbiAgICB0aGlzLkFkZEJsb2NrRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgdGhhdC5fYmxvY2tFeHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBTcGxpdElucHV0c1RvV29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhhdC5fb2xkV29yZHMgPSBIdG1sRGlmZi5Xb3JkU3BsaXR0ZXIuQ29udmVydEh0bWxUb0xpc3RPZldvcmRzKHRoYXQuX29sZFRleHQsIHRoYXQuX2Jsb2NrRXhwcmVzc2lvbnMpO1xyXG4gICAgICAgIHRoYXQuX29sZFRleHQgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGF0Ll9uZXdXb3JkcyA9IEh0bWxEaWZmLldvcmRTcGxpdHRlci5Db252ZXJ0SHRtbFRvTGlzdE9mV29yZHModGhhdC5fbmV3VGV4dCwgdGhhdC5fYmxvY2tFeHByZXNzaW9ucyk7XHJcbiAgICAgICAgdGhhdC5fbmV3VGV4dCA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IFBlcmZvcm1PcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24uQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgSHRtbERpZmYuQWN0aW9uLkVxdWFsOlxyXG4gICAgICAgICAgICAgICAgUHJvY2Vzc0VxdWFsT3BlcmF0aW9uKG9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBIdG1sRGlmZi5BY3Rpb24uRGVsZXRlOlxyXG4gICAgICAgICAgICAgICAgUHJvY2Vzc0RlbGV0ZU9wZXJhdGlvbihvcGVyYXRpb24sICdkaWZmZGVsJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBIdG1sRGlmZi5BY3Rpb24uSW5zZXJ0OlxyXG4gICAgICAgICAgICAgICAgUHJvY2Vzc0luc2VydE9wZXJhdGlvbihvcGVyYXRpb24sICdkaWZmaW5zJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBIdG1sRGlmZi5BY3Rpb24uTm9uZTpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEh0bWxEaWZmLkFjdGlvbi5SZXBsYWNlOlxyXG4gICAgICAgICAgICAgICAgUHJvY2Vzc1JlcGxhY2VPcGVyYXRpb24ob3BlcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgUHJvY2Vzc1JlcGxhY2VPcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgUHJvY2Vzc0RlbGV0ZU9wZXJhdGlvbihvcGVyYXRpb24sICdkaWZmbW9kJyk7XHJcbiAgICAgICAgUHJvY2Vzc0luc2VydE9wZXJhdGlvbihvcGVyYXRpb24sICdkaWZmbW9kJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IFByb2Nlc3NJbnNlcnRPcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBjc3NDbGFzcykge1xyXG4gICAgICAgIEluc2VydFRhZygnaW5zJywgY3NzQ2xhc3MsIHRoYXQuX25ld1dvcmRzLnNsaWNlKG9wZXJhdGlvbi5TdGFydEluTmV3LCBvcGVyYXRpb24uRW5kSW5OZXcpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgUHJvY2Vzc0RlbGV0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGNzc0NsYXNzKSB7XHJcbiAgICAgICAgSW5zZXJ0VGFnKCdkZWwnLCBjc3NDbGFzcywgdGhhdC5fb2xkV29yZHMuc2xpY2Uob3BlcmF0aW9uLlN0YXJ0SW5PbGQsIG9wZXJhdGlvbi5FbmRJbk9sZCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBQcm9jZXNzRXF1YWxPcGVyYXRpb24gPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgdGhhdC5fY29udGVudC5wdXNoKHRoYXQuX25ld1dvcmRzLnNsaWNlKG9wZXJhdGlvbi5TdGFydEluTmV3LCBvcGVyYXRpb24uRW5kSW5OZXcpLmpvaW4oJycpKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vICAgICBUaGlzIG1ldGhvZCBlbmNsb3NlcyB3b3JkcyB3aXRoaW4gYSBzcGVjaWZpZWQgdGFnIChpbnMgb3IgZGVsKSwgYW5kIGFkZHMgdGhpcyBpbnRvIFwiY29udGVudFwiLFxyXG4gICAgLy8vICAgICB3aXRoIGEgdHdpc3Q6IGlmIHRoZXJlIGFyZSB3b3JkcyBjb250YWluIHRhZ3MsIGl0IGFjdHVhbGx5IGNyZWF0ZXMgbXVsdGlwbGUgaW5zIG9yIGRlbCxcclxuICAgIC8vLyAgICAgc28gdGhhdCB0aGV5IGRvbid0IGluY2x1ZGUgYW55IGlucyBvciBkZWwuIFRoaXMgaGFuZGxlcyBjYXNlcyBsaWtlXHJcbiAgICAvLy8gICAgIG9sZDogJzxwPmE8L3A+J1xyXG4gICAgLy8vICAgICBuZXc6ICc8cD5hYjwvcD5cclxuICAgIC8vLyAgICAgPHA+XHJcbiAgICAvLy8gICAgICAgICBjPC9iPidcclxuICAgIC8vLyAgICAgICAgIGRpZmYgcmVzdWx0OiAnPHA+YTxpbnM+YjwvaW5zPjwvcD5cclxuICAgIC8vLyAgICAgICAgIDxwPlxyXG4gICAgLy8vICAgICAgICAgICAgIDxpbnM+YzwvaW5zPlxyXG4gICAgLy8vICAgICAgICAgPC9wPlxyXG4gICAgLy8vICAgICAgICAgJ1xyXG4gICAgLy8vICAgICAgICAgdGhpcyBzdGlsbCBkb2Vzbid0IGd1YXJhbnRlZSB2YWxpZCBIVE1MIChoaW50OiB0aGluayBhYm91dCBkaWZmaW5nIGEgdGV4dCBjb250YWluaW5nIGlucyBvclxyXG4gICAgLy8vICAgICAgICAgZGVsIHRhZ3MpLCBidXQgaGFuZGxlcyBjb3JyZWN0bHkgbW9yZSBjYXNlcyB0aGFuIHRoZSBlYXJsaWVyIHZlcnNpb24uXHJcbiAgICAvLy8gICAgICAgICBQLlMuOiBTcGFyZSBhIHRob3VnaHQgZm9yIHBlb3BsZSB3aG8gd3JpdGUgSFRNTCBicm93c2Vycy4gVGhleSBsaXZlIGluIHRoaXMgLi4uIGV2ZXJ5IGRheS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0YWdcIj48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiY3NzQ2xhc3NcIj48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwid29yZHNcIj48L3BhcmFtPlxyXG4gICAgY29uc3QgSW5zZXJ0VGFnID0gZnVuY3Rpb24gKHRhZywgY3NzQ2xhc3MsIHdvcmRzKSB7XHJcbiAgICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IG5vblRhZ3MgPSBFeHRyYWN0Q29uc2VjdXRpdmVXb3Jkcyh3b3JkcywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICFIdG1sRGlmZi5VdGlscy5Jc1RhZyh4KTsgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3BlY2lhbENhc2VUYWdJbmplY3Rpb24gPSAnJztcclxuICAgICAgICAgICAgbGV0IHNwZWNpYWxDYXNlVGFnSW5qZWN0aW9uSXNCZWZvcmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub25UYWdzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBIdG1sRGlmZi5VdGlscy5XcmFwVGV4dChub25UYWdzLmpvaW4oJycpLCB0YWcsIGNzc0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2NvbnRlbnQucHVzaCh0ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0YWcgaXMgYSBzcGVjaWFsIGNhc2VcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9zcGVjaWFsQ2FzZU9wZW5pbmdUYWdSZWdleC50ZXN0KHdvcmRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3NwZWNpYWxUYWdEaWZmU3RhY2sucHVzaCh3b3Jkc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbENhc2VUYWdJbmplY3Rpb24gPSAnPGlucyBjbGFzcz1cIm1vZFwiPic7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PSAnZGVsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRhZ3MgbWF5IGJlIGZvcm1hdHRpbmcgdGFncyBhcyB3ZWxsLCBmb2xsb3cgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod29yZHMubGVuZ3RoID4gMCAmJiB0aGF0Ll9zcGVjaWFsQ2FzZU9wZW5pbmdUYWdSZWdleC50ZXN0KHdvcmRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQuX3NwZWNpYWxDYXNlQ2xvc2luZ1RhZ3MuaGFzT3duUHJvcGVydHkod29yZHNbMF0udG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbmluZ1RhZyA9IHRoYXQuX3NwZWNpYWxUYWdEaWZmU3RhY2subGVuZ3RoID09PSAwID8gbnVsbCA6IHRoYXQuX3NwZWNpYWxUYWdEaWZmU3RhY2sucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBoYXZlIGFuIG9wZW5pbmcgdGFnLCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIHByZXZpb3VzIHRhZyB1c2VkIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nVGFnID09PSBudWxsIHx8IG9wZW5pbmdUYWcgIT0gd29yZHNbd29yZHMubGVuZ3RoIC0gMV0ucmVwbGFjZSgnLycsICcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQ2FzZVRhZ0luamVjdGlvbiA9ICc8L2lucz4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQ2FzZVRhZ0luamVjdGlvbklzQmVmb3JlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT0gJ2RlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0YWdzIG1heSBiZSBmb3JtYXR0aW5nIHRhZ3MgYXMgd2VsbCwgZm9sbG93IHRocm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDAgJiYgdGhhdC5fc3BlY2lhbENhc2VDbG9zaW5nVGFncy5oYXNPd25Qcm9wZXJ0eSh3b3Jkc1swXS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCAmJiBzcGVjaWFsQ2FzZVRhZ0luamVjdGlvbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3BlY2lhbENhc2VUYWdJbmplY3Rpb25Jc0JlZm9yZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY29udGVudC5wdXNoKHNwZWNpYWxDYXNlVGFnSW5qZWN0aW9uICsgRXh0cmFjdENvbnNlY3V0aXZlV29yZHMod29yZHMsIEh0bWxEaWZmLlV0aWxzLklzVGFnKS5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9jb250ZW50LnB1c2goRXh0cmFjdENvbnNlY3V0aXZlV29yZHMod29yZHMsIEh0bWxEaWZmLlV0aWxzLklzVGFnKS5qb2luKCcnKSArIHNwZWNpYWxDYXNlVGFnSW5qZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgRXh0cmFjdENvbnNlY3V0aXZlV29yZHMgPSBmdW5jdGlvbiAod29yZHMsIGNvbmRpdGlvbikge1xyXG4gICAgICAgIGxldCBpbmRleE9mRmlyc3RUYWcgPSBudWxsO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB3b3JkID0gd29yZHNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiB3b3JkID09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbaV0gPSAnJm5ic3A7JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24od29yZCkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4T2ZGaXJzdFRhZyA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGl0ZW1zO1xyXG4gICAgICAgIGlmIChpbmRleE9mRmlyc3RUYWcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaXRlbXMgPSB3b3Jkcy5zbGljZSgwLCBpbmRleE9mRmlyc3RUYWcpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhPZkZpcnN0VGFnID4gMCkge1xyXG4gICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKDAsIGluZGV4T2ZGaXJzdFRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW1zID0gd29yZHMuc2xpY2UoKTtcclxuICAgICAgICAgICAgd29yZHMuc3BsaWNlKDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBPcGVyYXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBwb3NpdGlvbkluT2xkID0gMCwgcG9zaXRpb25Jbk5ldyA9IDA7XHJcbiAgICAgICAgbGV0IG9wZXJhdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBNYXRjaGluZ0Jsb2NrcygpO1xyXG5cclxuICAgICAgICBtYXRjaGVzLnB1c2gobmV3IEh0bWxEaWZmLk1hdGNoKHRoYXQuX29sZFdvcmRzLmxlbmd0aCwgdGhhdC5fbmV3V29yZHMubGVuZ3RoLCAwKSk7XHJcblxyXG4gICAgICAgIC8vUmVtb3ZlIG9ycGhhbnMgZnJvbSBtYXRjaGVzLlxyXG4gICAgICAgIC8vSWYgZGlzdGFuY2UgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCBtYXRjaGVzIGlzIDQgdGltZXMgbG9uZ2VyIHRoYW4gbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggdGhlbiBpdCBpcyBjb25zaWRlcmVkIGFzIG9ycGhhblxyXG4gICAgICAgIHZhciBtYXRoZXNXaXRob3V0T3JwaGFucyA9IFJlbW92ZU9ycGhhbnMobWF0Y2hlcyk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0aGVzV2l0aG91dE9ycGhhbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG1hdGNoU3RhcnRzQXRDdXJyZW50UG9zaXRpb25Jbk9sZCA9IHBvc2l0aW9uSW5PbGQgPT0gbWF0aGVzV2l0aG91dE9ycGhhbnNbaV0uU3RhcnRJbk9sZDtcclxuICAgICAgICAgICAgbGV0IG1hdGNoU3RhcnRzQXRDdXJyZW50UG9zaXRpb25Jbk5ldyA9IHBvc2l0aW9uSW5OZXcgPT0gbWF0aGVzV2l0aG91dE9ycGhhbnNbaV0uU3RhcnRJbk5ldztcclxuXHJcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoU3RhcnRzQXRDdXJyZW50UG9zaXRpb25Jbk9sZCA9PT0gZmFsc2UgJiYgbWF0Y2hTdGFydHNBdEN1cnJlbnRQb3NpdGlvbkluTmV3ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gSHRtbERpZmYuQWN0aW9uLlJlcGxhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hTdGFydHNBdEN1cnJlbnRQb3NpdGlvbkluT2xkXHJcbiAgICAgICAgICAgICAgICAmJiBtYXRjaFN0YXJ0c0F0Q3VycmVudFBvc2l0aW9uSW5OZXcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBIdG1sRGlmZi5BY3Rpb24uSW5zZXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoU3RhcnRzQXRDdXJyZW50UG9zaXRpb25Jbk9sZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IEh0bWxEaWZmLkFjdGlvbi5EZWxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSAvLyBUaGlzIG9jY3VycyBpZiB0aGUgZmlyc3QgZmV3IHdvcmRzIGFyZSB0aGUgc2FtZSBpbiBib3RoIHZlcnNpb25zXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbiA9IEh0bWxEaWZmLkFjdGlvbi5Ob25lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYWN0aW9uICE9IEh0bWxEaWZmLkFjdGlvbi5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEh0bWxEaWZmLk9wZXJhdGlvbihhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5PbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhlc1dpdGhvdXRPcnBoYW5zW2ldLlN0YXJ0SW5PbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5OZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhlc1dpdGhvdXRPcnBoYW5zW2ldLlN0YXJ0SW5OZXcpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGhlc1dpdGhvdXRPcnBoYW5zW2ldLlNpemUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChuZXcgSHRtbERpZmYuT3BlcmF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIEh0bWxEaWZmLkFjdGlvbi5FcXVhbCxcclxuICAgICAgICAgICAgICAgICAgICBtYXRoZXNXaXRob3V0T3JwaGFuc1tpXS5TdGFydEluT2xkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGhlc1dpdGhvdXRPcnBoYW5zW2ldLkVuZEluT2xkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0aGVzV2l0aG91dE9ycGhhbnNbaV0uU3RhcnRJbk5ldyxcclxuICAgICAgICAgICAgICAgICAgICBtYXRoZXNXaXRob3V0T3JwaGFuc1tpXS5FbmRJbk5ldygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uSW5PbGQgPSBtYXRoZXNXaXRob3V0T3JwaGFuc1tpXS5FbmRJbk9sZCgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkluTmV3ID0gbWF0aGVzV2l0aG91dE9ycGhhbnNbaV0uRW5kSW5OZXcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBSZW1vdmVPcnBoYW5zID0gZnVuY3Rpb24gKG1hdGNoZXMpIHtcclxuICAgICAgICBsZXQgbWF0Y2hlc05vT3JwaGFucyA9IFtdO1xyXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcclxuICAgICAgICBsZXQgY3VyciA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2ID0gbmV3IEh0bWxEaWZmLk1hdGNoKDAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgY3VyciA9IG1hdGNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pZiBtYXRjaCBoYXMgbm8gZGlmZiBvbiB0aGUgbGVmdCBvciBvbiB0aGUgcmlnaHRcclxuICAgICAgICAgICAgaWYgKHByZXYuRW5kSW5PbGQoKSA9PSBjdXJyLlN0YXJ0SW5PbGQgJiYgcHJldi5FbmRJbk5ldygpID09IGN1cnIuU3RhcnRJbk5ldyB8fCBjdXJyLkVuZEluT2xkKCkgPT0gbWF0Y2hlc1tpXS5TdGFydEluT2xkICYmIGN1cnIuRW5kSW5OZXcoKSA9PSBtYXRjaGVzW2ldLlN0YXJ0SW5OZXcpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXNOb09ycGhhbnMucHVzaChuZXcgSHRtbERpZmYuTWF0Y2goY3Vyci5TdGFydEluT2xkLCBjdXJyLlN0YXJ0SW5OZXcsIGN1cnIuU2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgcHJldiA9IGN1cnI7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gbWF0Y2hlc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgajtcclxuICAgICAgICAgICAgdmFyIG9sZERpc3RhbmNlSW5DaGFycyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IE1hdGgubWluKHByZXYuRW5kSW5PbGQoKSwgbWF0Y2hlc1tpXS5TdGFydEluT2xkIC0gcHJldi5FbmRJbk9sZCgpKTsgaiA8IE1hdGgubWF4KHByZXYuRW5kSW5PbGQoKSwgbWF0Y2hlc1tpXS5TdGFydEluT2xkIC0gcHJldi5FbmRJbk9sZCgpKTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBvbGREaXN0YW5jZUluQ2hhcnMgKz0gdGhhdC5fb2xkV29yZHNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3RGlzdGFuY2VJbkNoYXJzID0gMDtcclxuICAgICAgICAgICAgZm9yIChqID0gTWF0aC5taW4ocHJldi5FbmRJbk5ldygpLCBtYXRjaGVzW2ldLlN0YXJ0SW5OZXcgLSBwcmV2LkVuZEluTmV3KCkpOyBqIDwgTWF0aC5tYXgocHJldi5FbmRJbk5ldygpLCBtYXRjaGVzW2ldLlN0YXJ0SW5OZXcgLSBwcmV2LkVuZEluTmV3KCkpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIG5ld0Rpc3RhbmNlSW5DaGFycyArPSB0aGF0Ll9uZXdXb3Jkc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyTWF0Y2hMZW5ndGhJbkNoYXJzID0gMDtcclxuICAgICAgICAgICAgZm9yIChqID0gTWF0aC5taW4oY3Vyci5TdGFydEluTmV3LCBjdXJyLkVuZEluTmV3KCkgLSBjdXJyLlN0YXJ0SW5OZXcpOyBqIDwgTWF0aC5tYXgoY3Vyci5TdGFydEluTmV3LCBjdXJyLkVuZEluTmV3KCkgLSBjdXJyLlN0YXJ0SW5OZXcpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGN1cnJNYXRjaExlbmd0aEluQ2hhcnMgKz0gdGhhdC5fbmV3V29yZHNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3Vyck1hdGNoTGVuZ3RoSW5DaGFycyA+IE1hdGgubWF4KG9sZERpc3RhbmNlSW5DaGFycywgbmV3RGlzdGFuY2VJbkNoYXJzKSAqIHRoYXQuT3JwaGFuTWF0Y2hUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXNOb09ycGhhbnMucHVzaChuZXcgSHRtbERpZmYuTWF0Y2goY3Vyci5TdGFydEluT2xkLCBjdXJyLlN0YXJ0SW5OZXcsIGN1cnIuU2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2ID0gY3VycjtcclxuICAgICAgICAgICAgY3VyciA9IG1hdGNoZXNbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRjaGVzTm9PcnBoYW5zLnB1c2gobmV3IEh0bWxEaWZmLk1hdGNoKGN1cnIuU3RhcnRJbk9sZCwgY3Vyci5TdGFydEluTmV3LCBjdXJyLlNpemUpKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlc05vT3JwaGFucztcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgTWF0Y2hpbmdCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nQmxvY2tzID0gW107XHJcbiAgICAgICAgRmluZE1hdGNoaW5nQmxvY2tzKDAsIHRoYXQuX29sZFdvcmRzLmxlbmd0aCwgMCwgdGhhdC5fbmV3V29yZHMubGVuZ3RoLCBtYXRjaGluZ0Jsb2Nrcyk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nQmxvY2tzO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBGaW5kTWF0Y2hpbmdCbG9ja3MgPSBmdW5jdGlvbiAoc3RhcnRJbk9sZCwgZW5kSW5PbGQsIHN0YXJ0SW5OZXcsIGVuZEluTmV3LCBtYXRjaGluZ0Jsb2Nrcykge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IEZpbmRNYXRjaChzdGFydEluT2xkLCBlbmRJbk9sZCwgc3RhcnRJbk5ldywgZW5kSW5OZXcpO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0SW5PbGQgPCBtYXRjaC5TdGFydEluT2xkICYmIHN0YXJ0SW5OZXcgPCBtYXRjaC5TdGFydEluTmV3KSB7XHJcbiAgICAgICAgICAgICAgICBGaW5kTWF0Y2hpbmdCbG9ja3Moc3RhcnRJbk9sZCwgbWF0Y2guU3RhcnRJbk9sZCwgc3RhcnRJbk5ldywgbWF0Y2guU3RhcnRJbk5ldywgbWF0Y2hpbmdCbG9ja3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtYXRjaGluZ0Jsb2Nrcy5wdXNoKG1hdGNoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXRjaC5FbmRJbk9sZCgpIDwgZW5kSW5PbGQgJiYgbWF0Y2guRW5kSW5OZXcoKSA8IGVuZEluTmV3KSB7XHJcbiAgICAgICAgICAgICAgICBGaW5kTWF0Y2hpbmdCbG9ja3MobWF0Y2guRW5kSW5PbGQoKSwgZW5kSW5PbGQsIG1hdGNoLkVuZEluTmV3KCksIGVuZEluTmV3LCBtYXRjaGluZ0Jsb2Nrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IEZpbmRNYXRjaCA9IGZ1bmN0aW9uIChzdGFydEluT2xkLCBlbmRJbk9sZCwgc3RhcnRJbk5ldywgZW5kSW5OZXcpIHtcclxuICAgICAgICAvLyBGb3IgbGFyZ2UgdGV4dHMgaXQgaXMgbW9yZSBsaWtlbHkgdGhhdCB0aGVyZSBpcyBhIE1hdGNoIG9mIHNpemUgYmlnZ2VyIHRoYW4gbWF4aW11bSBncmFudWxhcml0eS5cclxuICAgICAgICAvLyBJZiBub3QgdGhlbiBnbyBkb3duIGFuZCB0cnkgdG8gZmluZCBpdCB3aXRoIHNtYWxsZXIgZ3JhbnVsYXJpdHkuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoYXQuX21hdGNoR3JhbnVsYXJpdHk7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBuZXcgSHRtbERpZmYuTWF0Y2hPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuQmxvY2tTaXplID0gaTtcclxuICAgICAgICAgICAgb3B0aW9ucy5SZXBlYXRpbmdXb3Jkc0FjY3VyYWN5ID0gdGhhdC5SZXBlYXRpbmdXb3Jkc0FjY3VyYWN5O1xyXG4gICAgICAgICAgICBvcHRpb25zLklnbm9yZVdoaXRlc3BhY2VEaWZmZXJlbmNlcyA9IHRoYXQuSWdub3JlV2hpdGVzcGFjZURpZmZlcmVuY2VzO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZpbmRlciA9IG5ldyBIdG1sRGlmZi5NYXRjaEZpbmRlcih0aGF0Ll9vbGRXb3JkcywgdGhhdC5fbmV3V29yZHMsIHN0YXJ0SW5PbGQsIGVuZEluT2xkLCBzdGFydEluTmV3LCBlbmRJbk5ldywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGZpbmRlci5GaW5kTWF0Y2goKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qIFNUQVRJQyBPQkpFQ1RTICovXHJcblxyXG5IdG1sRGlmZi5BY3Rpb24gPSB7XHJcbiAgICBFcXVhbDogMCxcclxuICAgIERlbGV0ZTogMSxcclxuICAgIEluc2VydDogMixcclxuICAgIE5vbmU6IDMsXHJcbiAgICBSZXBsYWNlOiA0XHJcbn07XHJcblxyXG5IdG1sRGlmZi5Nb2RlID0ge1xyXG4gICAgQ2hhcmFjdGVyOiAwLFxyXG4gICAgVGFnOiAxLFxyXG4gICAgV2hpdGVzcGFjZTogMixcclxuICAgIEVudGl0eTogM1xyXG59O1xyXG5cclxuSHRtbERpZmYuVXRpbHMgPSB7XHJcbiAgICBPcGVuaW5nVGFnUmVnZXg6IG5ldyBSZWdFeHAoL15cXHMqPFtePl0rPlxccyokLyksXHJcbiAgICBDbG9zaW5nVGFnVGV4UmVnZXg6IG5ldyBSZWdFeHAoL15cXHMqPFxcL1tePl0rPlxccyokLyksXHJcbiAgICBUYWdXb3JkUmVnZXg6IG5ldyBSZWdFeHAoLzxbXlxccz5dKy8pLFxyXG4gICAgV2hpdGVzcGFjZVJlZ2V4OiBuZXcgUmVnRXhwKC9eKFxcc3wmbmJzcDspKyQvKSxcclxuICAgIFdvcmRSZWdleDogbmV3IFJlZ0V4cCgvW1xcdyNAXSsvKSxcclxuICAgIFNwZWNpYWxDYXNlV29yZFRhZ3M6IFsnPGltZyddLFxyXG4gICAgSXNUYWc6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBIdG1sRGlmZi5VdGlscy5TcGVjaWFsQ2FzZVdvcmRUYWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChIdG1sRGlmZi5VdGlscy5TcGVjaWFsQ2FzZVdvcmRUYWdzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gSHRtbERpZmYuVXRpbHMuSXNPcGVuaW5nVGFnKGl0ZW0pIHx8IEh0bWxEaWZmLlV0aWxzLklzQ2xvc2luZ1RhZyhpdGVtKTtcclxuICAgIH0sXHJcbiAgICBJc09wZW5pbmdUYWc6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIEh0bWxEaWZmLlV0aWxzLk9wZW5pbmdUYWdSZWdleC50ZXN0KGl0ZW0pO1xyXG4gICAgfSxcclxuICAgIElzQ2xvc2luZ1RhZzogZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gSHRtbERpZmYuVXRpbHMuQ2xvc2luZ1RhZ1RleFJlZ2V4LnRlc3QoaXRlbSk7XHJcbiAgICB9LFxyXG4gICAgU3RyaXBUYWdBdHRyaWJ1dGVzOiBmdW5jdGlvbiAod29yZCkge1xyXG4gICAgICAgIGxldCBtYXRjaGVzID0gd29yZC5tYXRjaChIdG1sRGlmZi5VdGlscy5UYWdXb3JkUmVnZXgpO1xyXG4gICAgICAgIGxldCB0YWcgPSBtYXRjaGVzLmxlbmd0aCA+IDAgPyBtYXRjaGVzWzBdIDogJyc7XHJcbiAgICAgICAgd29yZCA9IHRhZyArICh3b3JkLmVuZHNXaXRoKCcvPicpID8gJy8+JyA6ICc+Jyk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmQ7XHJcbiAgICB9LFxyXG4gICAgV3JhcFRleHQ6IGZ1bmN0aW9uICh0ZXh0LCB0YWdOYW1lLCBjc3NDbGFzcykge1xyXG4gICAgICAgIHJldHVybiAnPCcgKyB0YWdOYW1lICsgJyBjbGFzcz1cIicgKyBjc3NDbGFzcyArICdcIj4nICsgdGV4dCArICc8LycgKyB0YWdOYW1lICsgJz4nO1xyXG4gICAgfSxcclxuICAgIElzU3RhcnRPZlRhZzogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWwgPT0gJzwnO1xyXG4gICAgfSxcclxuICAgIElzRW5kT2ZUYWc6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsID09ICc+JztcclxuICAgIH0sXHJcbiAgICBJc1N0YXJ0T2ZFbnRpdHk6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsID09ICcmJztcclxuICAgIH0sXHJcbiAgICBJc0VuZE9mRW50aXR5OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCA9PSAnOyc7XHJcbiAgICB9LFxyXG4gICAgSXNXaGl0ZVNwYWNlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gSHRtbERpZmYuVXRpbHMuV2hpdGVzcGFjZVJlZ2V4LnRlc3QodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIFN0cmlwQW55QXR0cmlidXRlczogZnVuY3Rpb24gKHdvcmQpIHtcclxuICAgICAgICBpZiAoSHRtbERpZmYuVXRpbHMuSXNUYWcod29yZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEh0bWxEaWZmLlV0aWxzLlN0cmlwVGFnQXR0cmlidXRlcyh3b3JkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB3b3JkO1xyXG4gICAgfSxcclxuICAgIElzV29yZDogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICByZXR1cm4gSHRtbERpZmYuVXRpbHMuV29yZFJlZ2V4LnRlc3QodGV4dCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5IdG1sRGlmZi5Xb3JkU3BsaXR0ZXIgPSB7XHJcbiAgICBDb252ZXJ0SHRtbFRvTGlzdE9mV29yZHM6IGZ1bmN0aW9uICh0ZXh0LCBibG9ja0V4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgbGV0IG1vZGUgPSBIdG1sRGlmZi5Nb2RlLkNoYXJhY3RlcjtcclxuICAgICAgICBsZXQgY3VycmVudFdvcmQgPSBbXTsgLy8gbmV3IExpc3Q8Y2hhcj4oKTtcclxuICAgICAgICBsZXQgd29yZHMgPSBbXTsgLy8gbmV3IExpc3Q8c3RyaW5nPigpO1xyXG5cclxuICAgICAgICBsZXQgYmxvY2tMb2NhdGlvbnMgPSBIdG1sRGlmZi5Xb3JkU3BsaXR0ZXIuRmluZEJsb2Nrcyh0ZXh0LCBibG9ja0V4cHJlc3Npb25zKTtcclxuXHJcbiAgICAgICAgbGV0IGlzQmxvY2tDaGVja1JlcXVpcmVkID0gYmxvY2tMb2NhdGlvbnMubGVuZ3RoID4gMDtcclxuICAgICAgICBsZXQgaXNHcm91cGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBncm91cGluZ1VudGlsID0gLTE7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBsZXQgY2hhcmFjdGVyID0gdGV4dFtpbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgZXhlY3V0aW5nIGJsb2NrIGNoZWNrcyBpZiB3ZSBkb24ndCBoYXZlIGFueSBibG9ja3MgdG8gY2hlY2sgZm9yIVxyXG4gICAgICAgICAgICBpZiAoaXNCbG9ja0NoZWNrUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgY29tcGxldGVkIGdyb3VwaW5nIGEgdGV4dCBzZXF1ZW5jZS9ibG9ja1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwaW5nVW50aWwgPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cGluZ1VudGlsID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNHcm91cGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gZ3JvdXAgdGhlIG5leHQgdGV4dCBzZXF1ZW5jZS9ibG9ja1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTG9jYXRpb25zLmhhc093blByb3BlcnR5KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzR3JvdXBpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nVW50aWwgPSBibG9ja0xvY2F0aW9uc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGdyb3VwaW5nLCB0aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hhdCB0eXBlIG9mIGNoYXJhY3RlciB3ZSBoYXZlLCBpdCdzIGdvaW5nIHRvIGJlIHRyZWF0ZWQgYXMgYSB3b3JkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gSHRtbERpZmYuTW9kZS5DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBIdG1sRGlmZi5Nb2RlLkNoYXJhY3RlcjpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEh0bWxEaWZmLlV0aWxzLklzU3RhcnRPZlRhZyhjaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V29yZC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKCc8Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBIdG1sRGlmZi5Nb2RlLlRhZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoSHRtbERpZmYuVXRpbHMuSXNTdGFydE9mRW50aXR5KGNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMucHVzaChjdXJyZW50V29yZC5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEh0bWxEaWZmLk1vZGUuRW50aXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChIdG1sRGlmZi5VdGlscy5Jc1doaXRlU3BhY2UoY2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdvcmQubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGN1cnJlbnRXb3JkLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQucHVzaChjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gSHRtbERpZmYuTW9kZS5XaGl0ZXNwYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChIdG1sRGlmZi5VdGlscy5Jc1dvcmQoY2hhcmFjdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoY3VycmVudFdvcmQubGVuZ3RoID09PSAwIHx8IEh0bWxEaWZmLlV0aWxzLklzV29yZChjdXJyZW50V29yZFtjdXJyZW50V29yZC5sZW5ndGggLSAxXSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V29yZC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBIdG1sRGlmZi5Nb2RlLlRhZzpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEh0bWxEaWZmLlV0aWxzLklzRW5kT2ZUYWcoY2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEh0bWxEaWZmLlV0aWxzLklzV2hpdGVTcGFjZShjaGFyYWN0ZXIpID8gSHRtbERpZmYuTW9kZS5XaGl0ZXNwYWNlIDogSHRtbERpZmYuTW9kZS5DaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgSHRtbERpZmYuTW9kZS5XaGl0ZXNwYWNlOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoSHRtbERpZmYuVXRpbHMuSXNTdGFydE9mVGFnKGNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMucHVzaChjdXJyZW50V29yZC5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQucHVzaChjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gSHRtbERpZmYuTW9kZS5UYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEh0bWxEaWZmLlV0aWxzLklzU3RhcnRPZkVudGl0eShjaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V29yZC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBIdG1sRGlmZi5Nb2RlLkVudGl0eTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoSHRtbERpZmYuVXRpbHMuSXNXaGl0ZVNwYWNlKGNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQucHVzaChjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMucHVzaChjdXJyZW50V29yZC5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEh0bWxEaWZmLk1vZGUuQ2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEh0bWxEaWZmLk1vZGUuRW50aXR5OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChIdG1sRGlmZi5VdGlscy5Jc1N0YXJ0T2ZUYWcoY2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdvcmQubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGN1cnJlbnRXb3JkLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQucHVzaChjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gSHRtbERpZmYuTW9kZS5UYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEh0bWxEaWZmLlV0aWxzLklzV2hpdGVTcGFjZShjaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V29yZC5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLnB1c2goY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEh0bWxEaWZmLk1vZGUuV2hpdGVzcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoSHRtbERpZmYuVXRpbHMuSXNFbmRPZkVudGl0eShjaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzd2l0Y2hUb05leHRNb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGN1cnJlbnRXb3JkLmpvaW4oJycpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2pvaW4gJm5ic3A7IGVudGl0eSB3aXRoIGxhc3Qgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA+IDIgJiYgSHRtbERpZmYuVXRpbHMuSXNXaGl0ZVNwYWNlKHdvcmRzW3dvcmRzLmxlbmd0aCAtIDJdKSAmJiBIdG1sRGlmZi5VdGlscy5Jc1doaXRlU3BhY2Uod29yZHNbd29yZHMubGVuZ3RoIC0gMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcxID0gd29yZHNbd29yZHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcyID0gd29yZHNbd29yZHMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLmNvbmNhdCh3MS5zcGxpdCgnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JkLmNvbmNhdCh3Mi5zcGxpdCgnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBIdG1sRGlmZi5Nb2RlLldoaXRlc3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG9OZXh0TW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dpdGNoVG9OZXh0TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBIdG1sRGlmZi5Nb2RlLkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChIdG1sRGlmZi5VdGlscy5Jc1dvcmQoY2hhcmFjdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdvcmQubGVuZ3RoICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29yZC5wdXNoKGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSBIdG1sRGlmZi5Nb2RlLkNoYXJhY3RlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRXb3JkLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgIHdvcmRzLnB1c2goY3VycmVudFdvcmQuam9pbignJykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHdvcmRzO1xyXG4gICAgfSxcclxuICAgIEZpbmRCbG9ja3M6IGZ1bmN0aW9uICh0ZXh0LCBibG9ja0V4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgbGV0IGJsb2NrTG9jYXRpb25zID0ge307IC8vIG5ldyBEaWN0aW9uYXJ5PGludCwgaW50PigpO1xyXG5cclxuICAgICAgICBpZiAoYmxvY2tFeHByZXNzaW9ucyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9ja0xvY2F0aW9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tFeHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IHRleHQubWF0Y2goYmxvY2tFeHByZXNzaW9uc1tpXSk7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaEVuZCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGV4dC5pbmRleE9mKG1hdGNoZXNbal0sIG1hdGNoRW5kKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrTG9jYXRpb25zLkFkZChpbmRleCwgaW5kZXggKyBtYXRjaGVzW2pdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaEVuZCA9IGluZGV4ICsgbWF0Y2hlc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBibG9ja0xvY2F0aW9ucztcclxuICAgIH1cclxufTtcclxuXHJcbi8qIElOU1RBTlRJQVRFRCBPQkpFQ1RTICovXHJcblxyXG5IdG1sRGlmZi5NYXRjaCA9IGZ1bmN0aW9uIChzdGFydEluT2xkLCBzdGFydEluTmV3LCBzaXplKSB7XHJcbiAgICB0aGlzLlN0YXJ0SW5PbGQgPSBzdGFydEluT2xkO1xyXG4gICAgdGhpcy5TdGFydEluTmV3ID0gc3RhcnRJbk5ldztcclxuICAgIHRoaXMuU2l6ZSA9IHNpemU7XHJcbiAgICB0aGlzLkVuZEluT2xkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLlN0YXJ0SW5PbGQgKyB0aGlzLlNpemU7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5FbmRJbk5ldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5TdGFydEluTmV3ICsgdGhpcy5TaXplO1xyXG4gICAgfTtcclxufTtcclxuXHJcbkh0bWxEaWZmLk9wZXJhdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXJ0SW5PbGQsIGVuZEluT2xkLCBzdGFydEluTmV3LCBlbmRJbk5ldykge1xyXG4gICAgdGhpcy5BY3Rpb24gPSBhY3Rpb247XHJcbiAgICB0aGlzLlN0YXJ0SW5PbGQgPSBzdGFydEluT2xkO1xyXG4gICAgdGhpcy5FbmRJbk9sZCA9IGVuZEluT2xkO1xyXG4gICAgdGhpcy5TdGFydEluTmV3ID0gc3RhcnRJbk5ldztcclxuICAgIHRoaXMuRW5kSW5OZXcgPSBlbmRJbk5ldztcclxufTtcclxuXHJcbkh0bWxEaWZmLk1hdGNoT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuQmxvY2tTaXplID0gMDtcclxuICAgIHRoaXMuUmVwZWF0aW5nV29yZHNBY2N1cmFjeSA9IDA7XHJcbiAgICB0aGlzLklnbm9yZVdoaXRlc3BhY2VEaWZmZXJlbmNlcyA9IGZhbHNlO1xyXG59O1xyXG5cclxuSHRtbERpZmYuTWF0Y2hGaW5kZXIgPSBmdW5jdGlvbiAob2xkV29yZHMsIG5ld1dvcmRzLCBzdGFydEluT2xkLCBlbmRJbk9sZCwgc3RhcnRJbk5ldywgZW5kSW5OZXcsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX29sZFdvcmRzID0gb2xkV29yZHM7XHJcbiAgICB0aGlzLl9uZXdXb3JkcyA9IG5ld1dvcmRzO1xyXG4gICAgdGhpcy5fc3RhcnRJbk9sZCA9IHN0YXJ0SW5PbGQ7XHJcbiAgICB0aGlzLl9lbmRJbk9sZCA9IGVuZEluT2xkO1xyXG4gICAgdGhpcy5fc3RhcnRJbk5ldyA9IHN0YXJ0SW5OZXc7XHJcbiAgICB0aGlzLl9lbmRJbk5ldyA9IGVuZEluTmV3O1xyXG4gICAgdGhpcy5fd29yZEluZGljZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5JbmRleE5ld1dvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoYXQuX3dvcmRJbmRpY2VzID0ge307IC8vIG5ldyBEaWN0aW9uYXJ5PHN0cmluZywgTGlzdDxpbnQ+PigpO1xyXG4gICAgICAgIGxldCBibG9jayA9IFtdOyAvLyBuZXcgUXVldWU8c3RyaW5nPihfb3B0aW9ucy5CbG9ja1NpemUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGF0Ll9zdGFydEluTmV3OyBpIDwgdGhhdC5fZW5kSW5OZXc7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgd29yZCBpcyBhIHRhZywgd2Ugc2hvdWxkIGlnbm9yZSBhdHRyaWJ1dGVzIGFzIGF0dHJpYnV0ZSBjaGFuZ2VzIGFyZSBub3Qgc3VwcG9ydGVkICh5ZXQpXHJcbiAgICAgICAgICAgIGxldCB3b3JkID0gdGhhdC5Ob3JtYWxpemVGb3JJbmRleCh0aGF0Ll9uZXdXb3Jkc1tpXSk7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGF0LlB1dE5ld1dvcmQoYmxvY2ssIHdvcmQsIHRoYXQuX29wdGlvbnMuQmxvY2tTaXplKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGF0Ll93b3JkSW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll93b3JkSW5kaWNlc1trZXldLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll93b3JkSW5kaWNlc1trZXldID0gW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLlB1dE5ld1dvcmQgPSBmdW5jdGlvbiAoYmxvY2ssIHdvcmQsIGJsb2NrU2l6ZSkge1xyXG4gICAgICAgIGJsb2NrLnB1c2god29yZCk7XHJcbiAgICAgICAgaWYgKGJsb2NrLmxlbmd0aCA+IGJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICBibG9jay5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJsb2NrLmxlbmd0aCAhPSBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gYmxvY2tbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLk5vcm1hbGl6ZUZvckluZGV4ID0gZnVuY3Rpb24gKHdvcmQpIHtcclxuICAgICAgICB3b3JkID0gSHRtbERpZmYuVXRpbHMuU3RyaXBBbnlBdHRyaWJ1dGVzKHdvcmQpO1xyXG4gICAgICAgIGlmICh0aGF0Ll9vcHRpb25zLklnbm9yZVdoaXRlc3BhY2VEaWZmZXJlbmNlcyAmJiBIdG1sRGlmZi5VdGlscy5Jc1doaXRlU3BhY2Uod29yZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcgJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB3b3JkO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLkZpbmRNYXRjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGF0LkluZGV4TmV3V29yZHMoKTtcclxuICAgICAgICB0aGF0LlJlbW92ZVJlcGVhdGluZ1dvcmRzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGF0Ll93b3JkSW5kaWNlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBiZXN0TWF0Y2hJbk9sZCA9IHRoYXQuX3N0YXJ0SW5PbGQ7XHJcbiAgICAgICAgbGV0IGJlc3RNYXRjaEluTmV3ID0gdGhhdC5fc3RhcnRJbk5ldztcclxuICAgICAgICBsZXQgYmVzdE1hdGNoU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIHZhciBtYXRjaExlbmd0aEF0ID0ge307IC8vbmV3IERpY3Rpb25hcnk8aW50LCBpbnQ+KCk7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gW107IC8vbmV3IFF1ZXVlPHN0cmluZz4oX29wdGlvbnMuQmxvY2tTaXplKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXhJbk9sZCA9IHRoYXQuX3N0YXJ0SW5PbGQ7IGluZGV4SW5PbGQgPCB0aGF0Ll9lbmRJbk9sZDsgaW5kZXhJbk9sZCsrKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JkID0gdGhhdC5Ob3JtYWxpemVGb3JJbmRleCh0aGF0Ll9vbGRXb3Jkc1tpbmRleEluT2xkXSk7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoYXQuUHV0TmV3V29yZChibG9jaywgd29yZCwgdGhhdC5fb3B0aW9ucy5CbG9ja1NpemUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3TWF0Y2hMZW5ndGhBdCA9IHt9OyAvL25ldyBEaWN0aW9uYXJ5PGludCwgaW50PigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGF0Ll93b3JkSW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoQXQgPSBuZXdNYXRjaExlbmd0aEF0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhhdC5fd29yZEluZGljZXNbaW5kZXhdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWF0Y2hMZW5ndGggPSAobWF0Y2hMZW5ndGhBdC5oYXNPd25Qcm9wZXJ0eSh0aGF0Ll93b3JkSW5kaWNlc1tpbmRleF1baV0gLSAxKSA/IG1hdGNoTGVuZ3RoQXRbdGhhdC5fd29yZEluZGljZXNbaW5kZXhdW2ldIC0gMV0gOiAwKSArIDE7XHJcbiAgICAgICAgICAgICAgICBuZXdNYXRjaExlbmd0aEF0W3RoYXQuX3dvcmRJbmRpY2VzW2luZGV4XVtpXV0gPSBuZXdNYXRjaExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TWF0Y2hMZW5ndGggPiBiZXN0TWF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoSW5PbGQgPSBpbmRleEluT2xkIC0gbmV3TWF0Y2hMZW5ndGggKyAxIC0gdGhhdC5fb3B0aW9ucy5CbG9ja1NpemUgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaEluTmV3ID0gdGhhdC5fd29yZEluZGljZXNbaW5kZXhdW2ldIC0gbmV3TWF0Y2hMZW5ndGggKyAxIC0gdGhhdC5fb3B0aW9ucy5CbG9ja1NpemUgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaFNpemUgPSBuZXdNYXRjaExlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWF0Y2hMZW5ndGhBdCA9IG5ld01hdGNoTGVuZ3RoQXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYmVzdE1hdGNoU2l6ZSAhPSAwID8gbmV3IEh0bWxEaWZmLk1hdGNoKGJlc3RNYXRjaEluT2xkLCBiZXN0TWF0Y2hJbk5ldywgYmVzdE1hdGNoU2l6ZSArIHRoYXQuX29wdGlvbnMuQmxvY2tTaXplIC0gMSkgOiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLlJlbW92ZVJlcGVhdGluZ1dvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGF0Ll9uZXdXb3Jkcy5sZW5ndGggKiB0aGF0Ll9vcHRpb25zLlJlcGVhdGluZ1dvcmRzQWNjdXJhY3k7XHJcbiAgICAgICAgdmFyIHJlcGVhdGluZ1dvcmRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgdyBpbiB0aGF0Ll93b3JkSW5kaWNlcykge1xyXG4gICAgICAgICAgICBpZiAoIXRoYXQuX3dvcmRJbmRpY2VzLmhhc093blByb3BlcnR5KHcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoYXQuX3dvcmRJbmRpY2VzW3ddLmxlbmd0aCA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcmVwZWF0aW5nV29yZHMucHVzaCh3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXBlYXRpbmdXb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhhdC5fd29yZEluZGljZXNbcmVwZWF0aW5nV29yZHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIdG1sRGlmZjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ })

/******/ });
});